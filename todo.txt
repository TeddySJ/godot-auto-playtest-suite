== TODO RIGHT NOW ==

TEST NAMES:
	
	X Add a test_name variable to the Test resource
	
	X Implement a field in the editor where this name can be added and changed
	
	X Refactor the saved logs to have the first level of the dictionary refer to test_name, with Logger then becoming the second entry
	
	X When a new test is created, a name is assigned randomly
	
	X Make it so the editor "presses" the new_test button after loading

MULTIPLE TESTS:
	
	X Add a test_series_name variable to the TestSeries resource
	
	X Add a top panel called TestSeriesView which can display an arbitrary number of entries (buttons) connected to the loaded TestSeries
	
	X At the top, there's a field for the Series Name
	
	X Make the Add New button add a new test to the TestSeries, and update the TestSeriesView to reflect this
	
	X Make pressing the buttons switch which test is currently shown and loaded, and disabling the currently picked button (to show it is selected)
	
	Make it so that changing a test name also changes the text on its button
	
	Create buttons for Save Series, Load Series and Remove Test From Series to be displayed to the right of the buttons panel
	
	Implement functionality for removing a test from a series
	
	Implement functionality for saving and loading TestSeries
	
	Implement functionality to run a full series, keeping the logs from all run tests
		Refuse to run a series if any two upcoming test share the same name

=== SPECIFICATION ==

MAIN ENGINE:
	
	AutoPlaySuiteEditor:
		
		This does the coordination between all parts, as well as set up the different parts' interfaces.
		
		It is the only thing which knows not only about the current tests, but other available tests.
		
		Capability Specification:
			
			RUN SINGLE: 
				It must be able to launch an instance of the game and then run a FULL TEST
			
			RUN SERIES: 
				It must be able to be primed with a series of independent tests, which will launch its own instance of the game
			
			CANCEL SERIES:
				It must be possible to cancel the current series if the user realises it no longer serves to run them all
			
			BASIC/ADVANCED LOGGING: 
				It must be able to log a test, and if running a series, log all of them separately in an orderly fashion
				It must be able to communicate with the running debug session, and be fed back live data as the game progress
				There must be an option to save a log as a file
			
		UI Requirements / Levels:
			
			Top Level:
				
				Can hold MULTIPLE FULL TESTS at once in a SERIES, so the absolute TOP LEVEL must be able to show a list of these!
				
			Full Test:
				
				The view which encompasses both the action list, and the definitions of said action
				
			Saving/Loading:
				
				Must be able to save and load individual tests, as well as saving and loading whole test series
			
		

HOW A TEST FLOWS:
	
	1) A test is loaded into the AutoPlaySuiteEditor
	2) When the test is set to run: 
		an env variable is set to indicate that a test is supposed to be loaded
		the path to the resource file detailing that test is set to another env variable
	3) The game runs the test, optionally providing logging while doing it
	4) The game exits, and control is brought back to the plugin, which runs a new test (back to step 1) or cancels the queue

TESTS HANDLING "UNEXPECTED" GAME EVENTS (Game Over, Card Unlocks, etc):
	
	The test system must be able to define actions that are taken as a response when being interrupted unexpectedly!
	
	The TestRunner should have a function dedicated to "interrupt current flow with new action"
	
	Ideally, this should then be "hooked into" by the project using the plugin... like with a deferred call in some helper script
	that connects a callback with a function that in turn calls the TestRunner

LOGGING:
	
	AutoPlaySuiteLogger:
		
		A class that handles both the Editor and Game side of logging!
	
	How Logging is implemented:
		
		There is a "virtual" class called LoggerDefinition which can be extended by the user
		
		Base methods: setup(), _process(delta), _on_auto_play_action(resource), log(string), log_to_list(key, data, also_to_output : bool)
		
		The supposed use case is to connect to various signals in init() and then use connected functions to log
		
		It's also possible to send a message to a debugger via an autoplay instruction, to tell it to output certain log info at specific points in a test, for example
